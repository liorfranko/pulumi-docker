"use strict";
// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***
Object.defineProperty(exports, "__esModule", { value: true });
const pulumi = require("@pulumi/pulumi");
const utilities = require("../utilities");
/**
 * Provides an Elastic MapReduce Cluster, a web service that makes it easy to
 * process large amounts of data efficiently. See [Amazon Elastic MapReduce Documentation](https://aws.amazon.com/documentation/elastic-mapreduce/)
 * for more information.
 *
 * To configure [Instance Groups](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-instance-group-configuration.html#emr-plan-instance-groups) for [task nodes](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-master-core-task-nodes.html#emr-plan-task), see the `aws.emr.InstanceGroup` resource.
 *
 * > Support for [Instance Fleets](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-instance-group-configuration.html#emr-plan-instance-fleets) will be made available in an upcoming release.
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const cluster = new aws.emr.Cluster("cluster", {
 *     additionalInfo: `{
 *   "instanceAwsClientConfiguration": {
 *     "proxyPort": 8099,
 *     "proxyHost": "myproxy.example.com"
 *   }
 * }
 * `,
 *     applications: ["Spark"],
 *     bootstrapActions: [{
 *         args: [
 *             "instance.isMaster=true",
 *             "echo running on master node",
 *         ],
 *         name: "runif",
 *         path: "s3://elasticmapreduce/bootstrap-actions/run-if",
 *     }],
 *     configurationsJson: `  [
 *     {
 *       "Classification": "hadoop-env",
 *       "Configurations": [
 *         {
 *           "Classification": "export",
 *           "Properties": {
 *             "JAVA_HOME": "/usr/lib/jvm/java-1.8.0"
 *           }
 *         }
 *       ],
 *       "Properties": {}
 *     },
 *     {
 *       "Classification": "spark-env",
 *       "Configurations": [
 *         {
 *           "Classification": "export",
 *           "Properties": {
 *             "JAVA_HOME": "/usr/lib/jvm/java-1.8.0"
 *           }
 *         }
 *       ],
 *       "Properties": {}
 *     }
 *   ]
 * `,
 *     coreInstanceGroup: {
 *         autoscalingPolicy: `{
 * "Constraints": {
 *   "MinCapacity": 1,
 *   "MaxCapacity": 2
 * },
 * "Rules": [
 *   {
 *     "Name": "ScaleOutMemoryPercentage",
 *     "Description": "Scale out if YARNMemoryAvailablePercentage is less than 15",
 *     "Action": {
 *       "SimpleScalingPolicyConfiguration": {
 *         "AdjustmentType": "CHANGE_IN_CAPACITY",
 *         "ScalingAdjustment": 1,
 *         "CoolDown": 300
 *       }
 *     },
 *     "Trigger": {
 *       "CloudWatchAlarmDefinition": {
 *         "ComparisonOperator": "LESS_THAN",
 *         "EvaluationPeriods": 1,
 *         "MetricName": "YARNMemoryAvailablePercentage",
 *         "Namespace": "AWS/ElasticMapReduce",
 *         "Period": 300,
 *         "Statistic": "AVERAGE",
 *         "Threshold": 15.0,
 *         "Unit": "PERCENT"
 *       }
 *     }
 *   }
 * ]
 * }
 * `,
 *         bidPrice: "0.30",
 *         ebsConfigs: [{
 *             size: 40,
 *             type: "gp2",
 *             volumesPerInstance: 1,
 *         }],
 *         instanceCount: 1,
 *         instanceType: "c4.large",
 *     },
 *     ebsRootVolumeSize: 100,
 *     ec2Attributes: {
 *         emrManagedMasterSecurityGroup: aws_security_group_sg.id,
 *         emrManagedSlaveSecurityGroup: aws_security_group_sg.id,
 *         instanceProfile: aws_iam_instance_profile_emr_profile.arn,
 *         subnetId: aws_subnet_main.id,
 *     },
 *     keepJobFlowAliveWhenNoSteps: true,
 *     masterInstanceGroup: {
 *         instanceType: "m4.large",
 *     },
 *     releaseLabel: "emr-4.6.0",
 *     serviceRole: aws_iam_role_iam_emr_service_role.arn,
 *     tags: {
 *         env: "env",
 *         role: "rolename",
 *     },
 *     terminationProtection: false,
 * });
 * ```
 *
 * The `aws.emr.Cluster` resource typically requires two IAM roles, one for the EMR Cluster
 * to use as a service, and another to place on your Cluster Instances to interact
 * with AWS from those instances. The suggested role policy template for the EMR service is `AmazonElasticMapReduceRole`,
 * and `AmazonElasticMapReduceforEC2Role` for the EC2 profile. See the [Getting
 * Started](https://docs.aws.amazon.com/ElasticMapReduce/latest/ManagementGuide/emr-gs-launch-sample-cluster.html)
 * guide for more information on these IAM roles. There is also a fully-bootable
 * example this provider configuration at the bottom of this page.
 * ### Enable Debug Logging
 *
 * [Debug logging in EMR](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-plan-debugging.html)
 * is implemented as a step. It is highly recommended to utilize [`ignoreChanges`](https://www.pulumi.com/docs/intro/concepts/programming-model/#ignorechanges) if other
 * steps are being managed outside of this provider.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const example = new aws.emr.Cluster("example", {
 *     steps: [{
 *         actionOnFailure: "TERMINATE_CLUSTER",
 *         hadoopJarStep: {
 *             args: ["state-pusher-script"],
 *             jar: "command-runner.jar",
 *         },
 *         name: "Setup Hadoop Debugging",
 *     }],
 * }, { ignoreChanges: ["stepConcurrencyLevel", "steps"] });
 * ```
 * ### Multiple Node Master Instance Group
 *
 * Available in EMR version 5.23.0 and later, an EMR Cluster can be launched with three master nodes for high availability. Additional information about this functionality and its requirements can be found in the [EMR Management Guide](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-plan-ha.html).
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * // Map public IP on launch must be enabled for public (Internet accessible) subnets
 * const exampleSubnet = new aws.ec2.Subnet("example", {
 *     mapPublicIpOnLaunch: true,
 * });
 * const exampleCluster = new aws.emr.Cluster("example", {
 *     // core_instance_group must be configured
 *     coreInstanceGroup: {},
 *     ec2Attributes: {
 *         subnetId: exampleSubnet.id,
 *     },
 *     masterInstanceGroup: {
 *         // Master instance count must be set to 3
 *         instanceCount: 3,
 *     },
 *     // EMR version must be 5.23.0 or later
 *     releaseLabel: "emr-5.24.1",
 *     // Termination protection is automatically enabled for multiple masters
 *     // To destroy the cluster, this must be configured to false and applied first
 *     terminationProtection: true,
 * });
 * ```
 * ## Example bootable config
 *
 * **NOTE:** This configuration demonstrates a minimal configuration needed to
 * boot an example EMR Cluster. It is not meant to display best practices. Please
 * use at your own risk.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 *
 * const mainVpc = new aws.ec2.Vpc("mainVpc", {
 *     cidrBlock: "168.31.0.0/16",
 *     enableDnsHostnames: true,
 *     tags: {
 *         name: "emr_test",
 *     },
 * });
 * const mainSubnet = new aws.ec2.Subnet("mainSubnet", {
 *     vpcId: mainVpc.id,
 *     cidrBlock: "168.31.0.0/20",
 *     tags: {
 *         name: "emr_test",
 *     },
 * });
 * // IAM role for EMR Service
 * const iamEmrServiceRole = new aws.iam.Role("iamEmrServiceRole", {assumeRolePolicy: `{
 *   "Version": "2008-10-17",
 *   "Statement": [
 *     {
 *       "Sid": "",
 *       "Effect": "Allow",
 *       "Principal": {
 *         "Service": "elasticmapreduce.amazonaws.com"
 *       },
 *       "Action": "sts:AssumeRole"
 *     }
 *   ]
 * }
 * `});
 * // IAM Role for EC2 Instance Profile
 * const iamEmrProfileRole = new aws.iam.Role("iamEmrProfileRole", {assumeRolePolicy: `{
 *   "Version": "2008-10-17",
 *   "Statement": [
 *     {
 *       "Sid": "",
 *       "Effect": "Allow",
 *       "Principal": {
 *         "Service": "ec2.amazonaws.com"
 *       },
 *       "Action": "sts:AssumeRole"
 *     }
 *   ]
 * }
 * `});
 * const emrProfile = new aws.iam.InstanceProfile("emrProfile", {roles: [iamEmrProfileRole.name]});
 * const cluster = new aws.emr.Cluster("cluster", {
 *     releaseLabel: "emr-4.6.0",
 *     applications: ["Spark"],
 *     ec2Attributes: {
 *         subnetId: mainSubnet.id,
 *         emrManagedMasterSecurityGroup: aws_security_group.allow_all.id,
 *         emrManagedSlaveSecurityGroup: aws_security_group.allow_all.id,
 *         instanceProfile: emrProfile.arn,
 *     },
 *     masterInstanceType: "m5.xlarge",
 *     coreInstanceType: "m5.xlarge",
 *     coreInstanceCount: 1,
 *     tags: {
 *         role: "rolename",
 *         dns_zone: "env_zone",
 *         env: "env",
 *         name: "name-env",
 *     },
 *     bootstrapActions: [{
 *         path: "s3://elasticmapreduce/bootstrap-actions/run-if",
 *         name: "runif",
 *         args: [
 *             "instance.isMaster=true",
 *             "echo running on master node",
 *         ],
 *     }],
 *     configurationsJson: `  [
 *     {
 *       "Classification": "hadoop-env",
 *       "Configurations": [
 *         {
 *           "Classification": "export",
 *           "Properties": {
 *             "JAVA_HOME": "/usr/lib/jvm/java-1.8.0"
 *           }
 *         }
 *       ],
 *       "Properties": {}
 *     },
 *     {
 *       "Classification": "spark-env",
 *       "Configurations": [
 *         {
 *           "Classification": "export",
 *           "Properties": {
 *             "JAVA_HOME": "/usr/lib/jvm/java-1.8.0"
 *           }
 *         }
 *       ],
 *       "Properties": {}
 *     }
 *   ]
 * `,
 *     serviceRole: iamEmrServiceRole.arn,
 * });
 * const allowAccess = new aws.ec2.SecurityGroup("allowAccess", {
 *     description: "Allow inbound traffic",
 *     vpcId: mainVpc.id,
 *     ingress: [{
 *         fromPort: 0,
 *         toPort: 0,
 *         protocol: "-1",
 *         cidrBlocks: mainVpc.cidrBlock,
 *     }],
 *     egress: [{
 *         fromPort: 0,
 *         toPort: 0,
 *         protocol: "-1",
 *         cidrBlocks: ["0.0.0.0/0"],
 *     }],
 *     tags: {
 *         name: "emr_test",
 *     },
 * }, {
 *     dependsOn: ["aws_subnet.main"],
 * });
 * const gw = new aws.ec2.InternetGateway("gw", {vpcId: mainVpc.id});
 * const routeTable = new aws.ec2.RouteTable("routeTable", {
 *     vpcId: mainVpc.id,
 *     routes: [{
 *         cidrBlock: "0.0.0.0/0",
 *         gatewayId: gw.id,
 *     }],
 * });
 * const mainRouteTableAssociation = new aws.ec2.MainRouteTableAssociation("mainRouteTableAssociation", {
 *     vpcId: mainVpc.id,
 *     routeTableId: routeTable.id,
 * });
 * //##
 * const iamEmrServicePolicy = new aws.iam.RolePolicy("iamEmrServicePolicy", {
 *     role: iamEmrServiceRole.id,
 *     policy: `{
 *     "Version": "2012-10-17",
 *     "Statement": [{
 *         "Effect": "Allow",
 *         "Resource": "*",
 *         "Action": [
 *             "ec2:AuthorizeSecurityGroupEgress",
 *             "ec2:AuthorizeSecurityGroupIngress",
 *             "ec2:CancelSpotInstanceRequests",
 *             "ec2:CreateNetworkInterface",
 *             "ec2:CreateSecurityGroup",
 *             "ec2:CreateTags",
 *             "ec2:DeleteNetworkInterface",
 *             "ec2:DeleteSecurityGroup",
 *             "ec2:DeleteTags",
 *             "ec2:DescribeAvailabilityZones",
 *             "ec2:DescribeAccountAttributes",
 *             "ec2:DescribeDhcpOptions",
 *             "ec2:DescribeInstanceStatus",
 *             "ec2:DescribeInstances",
 *             "ec2:DescribeKeyPairs",
 *             "ec2:DescribeNetworkAcls",
 *             "ec2:DescribeNetworkInterfaces",
 *             "ec2:DescribePrefixLists",
 *             "ec2:DescribeRouteTables",
 *             "ec2:DescribeSecurityGroups",
 *             "ec2:DescribeSpotInstanceRequests",
 *             "ec2:DescribeSpotPriceHistory",
 *             "ec2:DescribeSubnets",
 *             "ec2:DescribeVpcAttribute",
 *             "ec2:DescribeVpcEndpoints",
 *             "ec2:DescribeVpcEndpointServices",
 *             "ec2:DescribeVpcs",
 *             "ec2:DetachNetworkInterface",
 *             "ec2:ModifyImageAttribute",
 *             "ec2:ModifyInstanceAttribute",
 *             "ec2:RequestSpotInstances",
 *             "ec2:RevokeSecurityGroupEgress",
 *             "ec2:RunInstances",
 *             "ec2:TerminateInstances",
 *             "ec2:DeleteVolume",
 *             "ec2:DescribeVolumeStatus",
 *             "ec2:DescribeVolumes",
 *             "ec2:DetachVolume",
 *             "iam:GetRole",
 *             "iam:GetRolePolicy",
 *             "iam:ListInstanceProfiles",
 *             "iam:ListRolePolicies",
 *             "iam:PassRole",
 *             "s3:CreateBucket",
 *             "s3:Get*",
 *             "s3:List*",
 *             "sdb:BatchPutAttributes",
 *             "sdb:Select",
 *             "sqs:CreateQueue",
 *             "sqs:Delete*",
 *             "sqs:GetQueue*",
 *             "sqs:PurgeQueue",
 *             "sqs:ReceiveMessage"
 *         ]
 *     }]
 * }
 * `,
 * });
 * const iamEmrProfilePolicy = new aws.iam.RolePolicy("iamEmrProfilePolicy", {
 *     role: iamEmrProfileRole.id,
 *     policy: `{
 *     "Version": "2012-10-17",
 *     "Statement": [{
 *         "Effect": "Allow",
 *         "Resource": "*",
 *         "Action": [
 *             "cloudwatch:*",
 *             "dynamodb:*",
 *             "ec2:Describe*",
 *             "elasticmapreduce:Describe*",
 *             "elasticmapreduce:ListBootstrapActions",
 *             "elasticmapreduce:ListClusters",
 *             "elasticmapreduce:ListInstanceGroups",
 *             "elasticmapreduce:ListInstances",
 *             "elasticmapreduce:ListSteps",
 *             "kinesis:CreateStream",
 *             "kinesis:DeleteStream",
 *             "kinesis:DescribeStream",
 *             "kinesis:GetRecords",
 *             "kinesis:GetShardIterator",
 *             "kinesis:MergeShards",
 *             "kinesis:PutRecord",
 *             "kinesis:SplitShard",
 *             "rds:Describe*",
 *             "s3:*",
 *             "sdb:*",
 *             "sns:*",
 *             "sqs:*"
 *         ]
 *     }]
 * }
 * `,
 * });
 * ```
 */
class Cluster extends pulumi.CustomResource {
    constructor(name, argsOrState, opts) {
        let inputs = {};
        if (opts && opts.id) {
            const state = argsOrState;
            inputs["additionalInfo"] = state ? state.additionalInfo : undefined;
            inputs["applications"] = state ? state.applications : undefined;
            inputs["arn"] = state ? state.arn : undefined;
            inputs["autoscalingRole"] = state ? state.autoscalingRole : undefined;
            inputs["bootstrapActions"] = state ? state.bootstrapActions : undefined;
            inputs["clusterState"] = state ? state.clusterState : undefined;
            inputs["configurations"] = state ? state.configurations : undefined;
            inputs["configurationsJson"] = state ? state.configurationsJson : undefined;
            inputs["coreInstanceCount"] = state ? state.coreInstanceCount : undefined;
            inputs["coreInstanceGroup"] = state ? state.coreInstanceGroup : undefined;
            inputs["coreInstanceType"] = state ? state.coreInstanceType : undefined;
            inputs["customAmiId"] = state ? state.customAmiId : undefined;
            inputs["ebsRootVolumeSize"] = state ? state.ebsRootVolumeSize : undefined;
            inputs["ec2Attributes"] = state ? state.ec2Attributes : undefined;
            inputs["instanceGroups"] = state ? state.instanceGroups : undefined;
            inputs["keepJobFlowAliveWhenNoSteps"] = state ? state.keepJobFlowAliveWhenNoSteps : undefined;
            inputs["kerberosAttributes"] = state ? state.kerberosAttributes : undefined;
            inputs["logUri"] = state ? state.logUri : undefined;
            inputs["masterInstanceGroup"] = state ? state.masterInstanceGroup : undefined;
            inputs["masterInstanceType"] = state ? state.masterInstanceType : undefined;
            inputs["masterPublicDns"] = state ? state.masterPublicDns : undefined;
            inputs["name"] = state ? state.name : undefined;
            inputs["releaseLabel"] = state ? state.releaseLabel : undefined;
            inputs["scaleDownBehavior"] = state ? state.scaleDownBehavior : undefined;
            inputs["securityConfiguration"] = state ? state.securityConfiguration : undefined;
            inputs["serviceRole"] = state ? state.serviceRole : undefined;
            inputs["stepConcurrencyLevel"] = state ? state.stepConcurrencyLevel : undefined;
            inputs["steps"] = state ? state.steps : undefined;
            inputs["tags"] = state ? state.tags : undefined;
            inputs["terminationProtection"] = state ? state.terminationProtection : undefined;
            inputs["visibleToAllUsers"] = state ? state.visibleToAllUsers : undefined;
        }
        else {
            const args = argsOrState;
            if (!args || args.releaseLabel === undefined) {
                throw new Error("Missing required property 'releaseLabel'");
            }
            if (!args || args.serviceRole === undefined) {
                throw new Error("Missing required property 'serviceRole'");
            }
            inputs["additionalInfo"] = args ? args.additionalInfo : undefined;
            inputs["applications"] = args ? args.applications : undefined;
            inputs["autoscalingRole"] = args ? args.autoscalingRole : undefined;
            inputs["bootstrapActions"] = args ? args.bootstrapActions : undefined;
            inputs["configurations"] = args ? args.configurations : undefined;
            inputs["configurationsJson"] = args ? args.configurationsJson : undefined;
            inputs["coreInstanceCount"] = args ? args.coreInstanceCount : undefined;
            inputs["coreInstanceGroup"] = args ? args.coreInstanceGroup : undefined;
            inputs["coreInstanceType"] = args ? args.coreInstanceType : undefined;
            inputs["customAmiId"] = args ? args.customAmiId : undefined;
            inputs["ebsRootVolumeSize"] = args ? args.ebsRootVolumeSize : undefined;
            inputs["ec2Attributes"] = args ? args.ec2Attributes : undefined;
            inputs["instanceGroups"] = args ? args.instanceGroups : undefined;
            inputs["keepJobFlowAliveWhenNoSteps"] = args ? args.keepJobFlowAliveWhenNoSteps : undefined;
            inputs["kerberosAttributes"] = args ? args.kerberosAttributes : undefined;
            inputs["logUri"] = args ? args.logUri : undefined;
            inputs["masterInstanceGroup"] = args ? args.masterInstanceGroup : undefined;
            inputs["masterInstanceType"] = args ? args.masterInstanceType : undefined;
            inputs["name"] = args ? args.name : undefined;
            inputs["releaseLabel"] = args ? args.releaseLabel : undefined;
            inputs["scaleDownBehavior"] = args ? args.scaleDownBehavior : undefined;
            inputs["securityConfiguration"] = args ? args.securityConfiguration : undefined;
            inputs["serviceRole"] = args ? args.serviceRole : undefined;
            inputs["stepConcurrencyLevel"] = args ? args.stepConcurrencyLevel : undefined;
            inputs["steps"] = args ? args.steps : undefined;
            inputs["tags"] = args ? args.tags : undefined;
            inputs["terminationProtection"] = args ? args.terminationProtection : undefined;
            inputs["visibleToAllUsers"] = args ? args.visibleToAllUsers : undefined;
            inputs["arn"] = undefined /*out*/;
            inputs["clusterState"] = undefined /*out*/;
            inputs["masterPublicDns"] = undefined /*out*/;
        }
        if (!opts) {
            opts = {};
        }
        if (!opts.version) {
            opts.version = utilities.getVersion();
        }
        super(Cluster.__pulumiType, name, inputs, opts);
    }
    /**
     * Get an existing Cluster resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    static get(name, id, state, opts) {
        return new Cluster(name, state, Object.assign(Object.assign({}, opts), { id: id }));
    }
    /**
     * Returns true if the given object is an instance of Cluster.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    static isInstance(obj) {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Cluster.__pulumiType;
    }
}
exports.Cluster = Cluster;
/** @internal */
Cluster.__pulumiType = 'aws:emr/cluster:Cluster';
//# sourceMappingURL=cluster.js.map